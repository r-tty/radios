;*******************************************************************************
;  rsl.as - Radiant System Loader, version 1.1
;  Copyright (c) 1999 RET & COM Research.
;*******************************************************************************

section .text
bits 16

		; Errors handling routine.
proc error
	push	ebp
	mov	ebp,esp
	push	ebx
	mov	ebx,dword [ebp+08h]
;
; line 132:	  if(errcode)
;
	test	ebx,ebx
	je	near	l_52
;
; line 134:	    if(errcode>=8) wrstring("fatal ");
;
	cmp	ebx,byte 08h
	jl	short	l_54
	lea	eax,[l_44]
	push	eax
	call	_wrstring
	pop	ecx
l_54:
;
; line 135:	    wrstring("error: ");
;
	lea	eax,[l_45]
	push	eax
	call	_wrstring
	pop	ecx
;
; line 136:	    switch(errcode)
;
	cmp	ebx,dword 01h
	je	short	l_58
	cmp	ebx,dword 02h
	je	near	l_59
	cmp	ebx,dword 03h
	je	near	l_60
	cmp	ebx,dword 08h
	je	near	l_61
	jmp	l_56
l_58:
;
; line 138:	      case 1: wrstring("disk operation failure");
;
	lea	eax,[l_46]
	push	eax
	call	_wrstring
	pop	ecx
;
; line 139:	      break;case 2: wrstring("startup configuration data not found");
;
	jmp	l_57
l_59:
	lea	eax,[l_47]
	push	eax
	call	_wrstring
	pop	ecx
;
; line 140:	      break;case 3: wrstring("boot sector signature not found");
;
	jmp	l_57
l_60:
	lea	eax,[l_48]
	push	eax
	call	_wrstring
	pop	ecx
;
; line 141:	      break;case 8: wrstring("no loadable devices");
;
	jmp	l_57
l_61:
	lea	eax,[l_49]
	push	eax
	call	_wrstring
	pop	ecx
l_56:
l_57:
;
; line 143:	   }
;
	jmp	l_53
l_52:
;
; line 144:	  else wrstring("program terminated normally");
;
	lea	eax,[l_50]
	push	eax
	call	_wrstring
	pop	ecx
l_53:
;
; line 145:	  wrstring(". press any key...\n");
;
	lea	eax,[l_51]
	push	eax
	call	_wrstring
	pop	ecx
;
; line 146:	  waitkey();
;
	call	_waitkey
;
; line 147:	  errorcode=errcode;
;
	mov	dword [_errorcode],ebx
;
; line 148:	 }
;
	pop	ebx
	pop	ebp
	ret
;
; line 153:	 {
;
_help:
	ret
;
; line 159:	 {
;
_lightline:
	push	ebp
	mov	ebp,esp
	sub	esp,byte 04h
	push	ebx
;
; line 160:	  byte hlattr=127,k;
;
	mov	byte [ebp+0ffffffffh],07fh
;
; line 162:	  if(*currvidmode==7) hlattr=112;
;
	mov	eax,dword [_currvidmode]
	movsx	eax,byte [eax+00h]
	cmp	eax,byte 07h
	jne	short	l_62
	mov	byte [ebp+0ffffffffh],070h
l_62:
	mov	bl,05h
	jmp	l_66
l_64:
	movzx	eax,byte [ebp+0ffffffffh]
	push	eax
	movzx	ax,byte [ebp+08h]
	add	ax,byte 05h
	imul	ax,0a0h
	movzx	ebx,bl
	add	eax,ebx
	push	eax
	call	_wrvidmem
	add	esp,byte 08h
;
; line 163:	  for(k=5;k<78*2;k+=2) wrvidmem((row+5)*160+k,hlattr);
;
l_65:
	add	bl,byte 02h
l_66:
	movzx	ebx,bl
	cmp	ebx,09ch
	jb	near	l_64
l_67:
;
; line 164:	 }
;
	pop	ebx
	mov	esp,ebp
	pop	ebp
	ret
;
; line 169:	 {
;
_blankline:
	push	ebp
	mov	ebp,esp
	push	ebx
	mov	bl,05h
	jmp	l_70
l_68:
	push	byte 07h
	movzx	ax,byte [ebp+08h]
	add	ax,byte 05h
	imul	ax,0a0h
	movzx	ebx,bl
	add	eax,ebx
	push	eax
	call	_wrvidmem
	add	esp,byte 08h
;
; line 172:	  for(k=5;k<79*2;k+=2) wrvidmem((row+5)*160+k,7);
;
l_69:
	add	bl,byte 02h
l_70:
	movzx	ebx,bl
	cmp	ebx,09eh
	jb	near	l_68
l_71:
;
; line 173:	 }
;
	pop	ebx
	pop	ebp
	ret
;
; line 178:	 {
;
_getstring:
	push	ebp
	mov	ebp,esp
	sub	esp,byte 018h
	push	ebx
	push	esi
	push	edi
	mov	esi,dword [ebp+0ch]
;
; line 182:	  wrstring(prompt);
;
	push	dword [ebp+08h]
	call	_wrstring
	pop	ecx
;
; line 183:	  if((k=m=strlen(edstr))!=0) wrstring(strcopy(tmpbuf,edstr));
;
	push	esi
	call	_strlen
	pop	ecx
	mov	byte [ebp+0ffffffeah],al
	mov	bl,al
	movsx	eax,al
	test	eax,eax
	je	short	l_73
	push	esi
	lea	eax,[ebp+0ffffffech]
	push	eax
	call	_strcopy
	add	esp,byte 08h
	push	eax
	call	_wrstring
	pop	ecx
l_73:
	jmp	l_77
l_75:
;
; line 186:	    switch(ch=bkey=waitkey())
;
	call	_waitkey
	mov	edi,eax
	mov	byte [ebp+0ffffffebh],al
	cmp	al,byte 09h
	je	near	l_85
	jg	short	l_87
	cmp	al,byte 08h
	je	near	l_82
	jg	near	l_79
	cmp	al,byte 00h
	je	short	l_81
	jmp	l_79
l_87:
	cmp	al,byte 01bh
	je	near	l_84
	jg	near	l_79
	cmp	al,byte 0dh
	je	near	l_83
	jmp	l_79
l_81:
;
; line 188:	       case '\0': switch(bkey >> 8)
;
	mov	eax,edi
	shr	eax,08h
	cmp	eax,dword 03bh
	jne	near	l_88
l_90:
;
; line 190:			    case 59: help();
;
	call	_help
;
; line 191:					 wrstring(prompt);
;
	push	dword [ebp+08h]
	call	_wrstring
	pop	ecx
;
; line 192:					 tmpbuf[k]='\0';
;
	movsx	ebx,bl
	mov	byte [ebp+ebx+0ffffffech],00h
;
; line 193:					 wrstring(tmpbuf);
;
	lea	eax,[ebp+0ffffffech]
	push	eax
	call	_wrstring
	pop	ecx
;
; line 194:					 break;
;
l_88:
l_89:
;
; line 196:			  continue;
;
	jmp	l_76
l_82:
;
; line 197:	       case '\b': if(k)
;
	test	bl,bl
	je	short	l_91
;
; line 198:			   { k--;
;
	dec	bl
;
; line 199:			     wrstring("\b \b");
;
	lea	eax,[l_72]
	push	eax
	call	_wrstring
	pop	ecx
;
; line 200:			   }
;
l_91:
;
; line 201:			  continue;
;
	jmp	l_76
l_83:
;
; line 202:	       case '\r': tmpbuf[k]='\0';
;
	movsx	ebx,bl
	mov	byte [ebp+ebx+0ffffffech],00h
;
; line 203:			  strcopy(edstr,tmpbuf);
;
	lea	eax,[ebp+0ffffffech]
	push	eax
	push	esi
	call	_strcopy
	add	esp,byte 08h
;
; line 204:			  wrchar('\n');
;
	push	byte 0ah
	call	_wrchar
	pop	ecx
;
; line 205:			  return edstr;
;
	mov	eax,esi
	jmp	l_93
l_84:
;
; line 206:	       case 27:  strcopy(tmpbuf,edstr);
;
	push	esi
	lea	eax,[ebp+0ffffffech]
	push	eax
	call	_strcopy
	add	esp,byte 08h
	jmp	l_94
l_96:
	push	byte 08h
	call	_wrchar
	pop	ecx
l_94:
;
; line 207:			  while(k--) wrchar('\b');
;
	mov	al,bl
	dec	bl
	test	al,al
	jne	short	l_96
l_95:
;
; line 208:			  wrstring(tmpbuf);
;
	lea	eax,[ebp+0ffffffech]
	push	eax
	call	_wrstring
	pop	ecx
	mov	bl,00h
	jmp	l_99
l_97:
	push	byte 020h
	call	_wrchar
	pop	ecx
;
; line 209:			  for(k=0;k<=16					;k++) wrchar(' ');
;
l_98:
	inc	bl
l_99:
	movsx	ebx,bl
	cmp	ebx,byte 010h
	jle	short	l_97
l_100:
	jmp	l_101
l_103:
	push	byte 08h
	call	_wrchar
	pop	ecx
l_101:
;
; line 210:			  while(k--) wrchar('\b');
;
	mov	al,bl
	dec	bl
	test	al,al
	jne	short	l_103
l_102:
;
; line 211:			  k=m;
;
	mov	bl,byte [ebp+0ffffffeah]
;
; line 212:	       break;case 9:  
;
	jmp	l_80
l_85:
;
; line 213:			  wrstring(prompt);
;
	push	dword [ebp+08h]
	call	_wrstring
	pop	ecx
;
; line 214:			  tmpbuf[k]='\0';
;
	movsx	ebx,bl
	mov	byte [ebp+ebx+0ffffffech],00h
;
; line 215:			  wrstring(tmpbuf);
;
	lea	eax,[ebp+0ffffffech]
	push	eax
	call	_wrstring
	pop	ecx
;
; line 216:			  break;
;
	jmp	l_80
l_79:
;
; line 217:	       default:   if(k!=16					) wrchar(tmpbuf[k++]=ch);
;
	movsx	ebx,bl
	cmp	ebx,byte 010h
	je	near	l_104
	mov	al,bl
	inc	bl
	movsx	eax,al
	mov	cl,byte [ebp+0ffffffebh]
	mov	byte [ebp+eax+0ffffffech],cl
	movsx	ecx,cl
	push	ecx
	call	_wrchar
	pop	ecx
l_104:
l_80:
;
; line 219:	   }
;
;
; line 184:	  for(;;)
;
l_76:
l_77:
	jmp	l_75
l_78:
;
; line 220:	 }
;
l_93:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp,ebp
	pop	ebp
	ret
[global	_getcylfromcx]
;
; line 225:	 {
;
_getcylfromcx:
	push	ebp
	mov	ebp,esp
	sub	esp,byte 04h
	push	ebx
	movzx	ebx,word [ebp+08h]
;
; line 228:	  t=cx;
;
	mov	byte [ebp+0ffffffffh],bl
;
; line 229:	  return (cx >> 8)+256*(t >> 6) ;
;
	movzx	eax,bx
	sar	eax,08h
	movzx	ecx,byte [ebp+0ffffffffh]
	sar	ecx,06h
	sal	ecx,08h
	add	eax,ecx
l_106:
	pop	ebx
	mov	esp,ebp
	pop	ebp
	ret
[global	_getsecfromcx]
;
; line 235:	 {
;
_getsecfromcx:
	push	ebp
	mov	ebp,esp
;
; line 236:	  return cx & 0x3f;
;
	mov	ax,word [ebp+08h]
	and	ax,byte 03fh
l_107:
	pop	ebp
	ret
[global	_loadbootsec]
;
; line 242:	 {
;
_loadbootsec:
	push	ebp
	mov	ebp,esp
	sub	esp,byte 0ch
	push	ebx
	push	esi
	push	edi
;
; line 247:	  drv=devinfo[devnum].minor;
;
	movzx	eax,byte [ebp+08h]
	imul	eax,byte 033h
	mov	al,byte [eax+03h+_devinfo+00h]
	mov	byte [ebp+0fffffffch],al
;
; line 248:	  if(devinfo[devnum].devid==2)
;
	movzx	eax,byte [ebp+08h]
	imul	eax,byte 033h
	movzx	eax,byte [eax+_devinfo+00h]
	cmp	eax,byte 02h
	jne	near	l_108
;
; line 253:	    if((t=devinfo[devnum].extended)!=0)
;
	movzx	eax,byte [ebp+08h]
	imul	eax,byte 033h
	movzx	ebx,word [eax+06h+_devinfo+00h]
	test	ebx,ebx
	je	near	l_110
;
; line 255:	      mbrptr=&extmbrs[(t>>8)-1];
;
	movzx	eax,bx
	sar	eax,08h
	dec	eax
	imul	eax,0202h
	lea	ecx,[_extmbrs]
	add	ecx,eax
	mov	dword [ebp+0fffffff4h],ecx
;
; line 256:	      part=(t & 0x3f)-1;
;
	mov	eax,ebx
	and	ax,byte 03fh
	dec	ax
	mov	esi,eax
;
; line 257:	     }
;
	jmp	l_111
l_110:
;
; line 260:	      mbrptr=&mainmbrs[drv];
;
	lea	eax,[_mainmbrs]
	movzx	ecx,byte [ebp+0fffffffch]
	imul	ecx,0202h
	add	eax,ecx
	mov	dword [ebp+0fffffff4h],eax
;
; line 261:	      part=devinfo[devnum].subminor-1;
;
	movzx	eax,byte [ebp+08h]
	imul	eax,byte 033h
	movzx	ax,byte [eax+04h+_devinfo+00h]
	dec	ax
	mov	esi,eax
;
; line 262:	     }
;
l_111:
;
; line 263:	    h=mbrptr->partentries[part].beginhead;
;
	mov	eax,dword [ebp+0fffffff4h]
	movzx	ecx,si
	shl	ecx,04h
	mov	al,byte [eax+ecx+01c1h+00h]
	mov	byte [ebp+0fffffffeh],al
;
; line 264:	    c=getcylfromcx(t=mbrptr->partentries[part].beginseccyl);
;
	mov	eax,dword [ebp+0fffffff4h]
	movzx	ecx,si
	shl	ecx,04h
	mov	bx,word [eax+ecx+01c2h+00h]
	movzx	ebx,word [eax+ecx+01c2h+00h]
	push	ebx
	call	_getcylfromcx
	pop	ecx
	mov	edi,eax
;
; line 265:	    s=getsecfromcx(t);
;
	movzx	ebx,bx
	push	ebx
	call	_getsecfromcx
	pop	ecx
	mov	byte [ebp+0ffffffffh],al
;
; line 267:	    drv+=0x80;
;
	add	byte [ebp+0fffffffch],080h
;
; line 268:	   }
;
	jmp	l_109
l_108:
;
; line 271:	    c=h=0;
;
	mov	byte [ebp+0fffffffeh],00h
	mov	di,00h
;
; line 272:	    s=1;
;
	mov	byte [ebp+0ffffffffh],01h
;
; line 273:	    t=1;
;
	mov	bx,01h
;
; line 274:	   }
;
l_109:
;
; line 276:	  if(diskoperation(drv,c,h,s,1,buffer,2)) error(1);
;
	push	byte 02h
	push	dword [ebp+0ch]
	push	byte 01h
	movzx	eax,byte [ebp+0ffffffffh]
	push	eax
	movzx	eax,byte [ebp+0fffffffeh]
	push	eax
	movzx	edi,di
	push	edi
	movzx	eax,byte [ebp+0fffffffch]
	push	eax
	call	_diskoperation
	add	esp,byte 01ch
	test	eax,eax
	je	short	l_112
	push	byte 01h
	call	_error
	pop	ecx
	jmp	l_113
l_112:
;
; line 277:	  else errorcode=0;
;
	mov	dword [_errorcode],00h
l_113:
;
; line 279:	  return errorcode;
;
	mov	eax,dword [_errorcode]
l_114:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp,ebp
	pop	ebp
	ret
;
; line 289:	 {
;
_filldevinfo:
	push	ebp
	mov	ebp,esp
	push	ebx
	push	esi
	push	edi
	movzx	ebx,byte [ebp+08h]
	movzx	edi,word [ebp+020h]
;
; line 292:	  devinfo[num].devid=devid;
;
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 033h
	mov	cl,byte [ebp+0ch]
	mov	byte [eax+_devinfo+00h],cl
;
; line 293:	  devinfo[num].typeid=typeid;
;
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 033h
	mov	cl,byte [ebp+010h]
	mov	byte [eax+01h+_devinfo+00h],cl
;
; line 294:	  devinfo[num].protid=protid;
;
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 033h
	mov	cl,byte [ebp+014h]
	mov	byte [eax+02h+_devinfo+00h],cl
;
; line 295:	  devinfo[num].minor=minor;
;
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 033h
	mov	cl,byte [ebp+018h]
	mov	byte [eax+03h+_devinfo+00h],cl
;
; line 296:	  devinfo[num].subminor=subminor;
;
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 033h
	mov	cl,byte [ebp+01ch]
	mov	byte [eax+04h+_devinfo+00h],cl
;
; line 297:	  devinfo[num].extended=extended;
;
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 033h
	mov	word [eax+06h+_devinfo+00h],di
;
; line 298:	  t=strend(strcopy(devinfo[num].name,name));
;
	push	dword [ebp+024h]
	lea	eax,[_devinfo]
	movzx	ebx,bl
	mov	ecx,ebx
	imul	ecx,byte 033h
	add	eax,ecx
	add	eax,byte 08h
	push	eax
	call	_strcopy
	add	esp,byte 08h
	push	eax
	call	_strend
	pop	ecx
	mov	esi,eax
;
; line 299:	  t[0]=minor+'1';
;
	mov	al,byte [ebp+018h]
	add	al,byte 031h
	mov	byte [esi+00h],al
;
; line 300:	  if(subminor)
;
	cmp	byte [ebp+01ch],byte 00h
	je	near	l_115
;
; line 302:	    t[1]='.';
;
	mov	byte [esi+01h],02eh
;
; line 303:	    if(extended)
;
	test	di,di
	je	near	l_117
;
; line 305:	      if((t[2]=(extended >> 8)+'4')>'9') t[2]+='a'-':';
;
	movzx	eax,di
	sar	eax,08h
	add	eax,byte 034h
	mov	byte [esi+02h],al
	movsx	eax,al
	cmp	eax,byte 039h
	jle	short	l_119
	add	byte [esi+02h],byte 027h
l_119:
;
; line 306:	     }
;
	jmp	l_118
l_117:
;
; line 307:	    else t[2]=subminor+'0';
;
	mov	al,byte [ebp+01ch]
	add	al,byte 030h
	mov	byte [esi+02h],al
l_118:
;
; line 308:	    t[3]=0;
;
	mov	byte [esi+03h],00h
;
; line 309:	   }
;
	jmp	l_116
l_115:
;
; line 310:	  else t[1]=0;
;
	mov	byte [esi+01h],00h
l_116:
;
; line 311:	  strcopy(devinfo[num].parms,parms);
;
	push	dword [ebp+028h]
	lea	eax,[_devinfo]
	movzx	ebx,bl
	mov	ecx,ebx
	imul	ecx,byte 033h
	add	eax,ecx
	add	eax,byte 01ch
	push	eax
	call	_strcopy
	add	esp,byte 08h
;
; line 312:	 }
;
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret
[global	_findfsname]
;
; line 317:	 {
;
_findfsname:
	push	ebp
	mov	ebp,esp
	push	ebx
	mov	bl,00h
	jmp	l_124
l_122:
;
; line 321:	   if(fstypeslist[k].sysid==id) return fstypeslist[k].type;
;
	movzx	ebx,bl
	mov	al,byte [ebx*8+_fstypeslist+00h]
	cmp	al,byte [ebp+08h]
	jne	short	l_126
	movzx	ebx,bl
	mov	eax,dword [ebx*8+04h+_fstypeslist+00h]
	jmp	l_128
l_126:
;
; line 320:	  for(k=0;k<31;k++)
;
l_123:
	inc	bl
l_124:
	movzx	ebx,bl
	cmp	ebx,byte 01fh
	jb	near	l_122
l_125:
;
; line 322:	  return unknown;
;
	lea	eax,[l_121]
l_128:
	pop	ebx
	pop	ebp
	ret
;
; line 337:	 {
;
_searchhdpartitions:
	push	ebp
	mov	ebp,esp
	sub	esp,byte 0ch
	push	ebx
	push	esi
	push	edi
;
; line 339:	  const pchar namehd="%hd";
;
	lea	eax,[l_129]
	mov	dword [ebp+0fffffffch],eax
;
; line 341:	  if(getdiskdriveparms(drive+0x80,&hddparms[drive])) return 0;
;
	lea	eax,[_hddparms]
	movzx	ecx,byte [ebp+08h]
	imul	ecx,byte 0ch
	add	eax,ecx
	push	eax
	mov	al,byte [ebp+08h]
	add	al,080h
	movzx	eax,al
	push	eax
	call	_getdiskdriveparms
	add	esp,byte 08h
	test	eax,eax
	je	short	l_130
	mov	al,00h
	jmp	l_132
l_130:
;
; line 343:	  diskoperation(drive+0x80,0,0,1,1,&mainmbrs[drive],2);
;
	push	byte 02h
	lea	eax,[_mainmbrs]
	movzx	ecx,byte [ebp+08h]
	imul	ecx,0202h
	add	eax,ecx
	push	eax
	push	byte 01h
	push	byte 01h
	push	byte 00h
	push	byte 00h
	mov	al,byte [ebp+08h]
	add	al,080h
	movzx	eax,al
	push	eax
	call	_diskoperation
	add	esp,byte 01ch
;
; line 344:	  if(mainmbrs[drive].signature==0xaa55)
;
	movzx	eax,byte [ebp+08h]
	imul	eax,0202h
	movzx	eax,word [eax+0200h+_mainmbrs+00h]
	cmp	eax,0aa55h
	jne	near	l_133
	mov	bl,00h
	jmp	l_137
l_135:
;
; line 347:	     if((c=mainmbrs[drive].partentries[k].systemcode)!=0)
;
	movzx	eax,byte [ebp+08h]
	imul	eax,0202h
	movzx	ecx,bl
	shl	ecx,04h
	mov	al,byte [eax+ecx+01c4h+_mainmbrs+00h+00h]
	mov	byte [ebp+0fffffffbh],al
	movzx	eax,al
	test	eax,eax
	je	near	l_139
;
; line 349:	       filldevinfo(*devcount,2,c,0, drive,k+1,0, namehd,findfsname(c));
;
	movzx	eax,byte [ebp+0fffffffbh]
	push	eax
	call	_findfsname
	pop	ecx
	push	eax
	push	dword [ebp+0fffffffch]
	push	byte 00h
	lea	eax,[ebx+01h]
	movzx	eax,al
	push	eax
	movzx	eax,byte [ebp+08h]
	push	eax
	push	byte 00h
	movzx	eax,byte [ebp+0fffffffbh]
	push	eax
	push	byte 02h
	mov	eax,dword [ebp+0ch]
	movzx	eax,byte [eax+00h]
	push	eax
	call	_filldevinfo
	add	esp,byte 024h
;
; line 350:	       (*devcount)++;
;
	mov	eax,dword [ebp+0ch]
	inc	byte [eax+00h]
;
; line 351:	      }
;
l_139:
;
; line 352:	     if(c==5)
;
	movzx	eax,byte [ebp+0fffffffbh]
	cmp	eax,byte 05h
	jne	near	l_141
;
; line 354:	       byte keepk=k, k1, embrcount=0, sec;
;
	mov	byte [ebp+0fffffff7h],bl
	mov	byte [ebp+0fffffff9h],00h
;
; line 356:	       tmbr *embr=&mainmbrs[drive];
;
	lea	eax,[_mainmbrs]
	movzx	ecx,byte [ebp+08h]
	imul	ecx,0202h
	add	eax,ecx
	mov	edi,eax
;
; line 358:	       do {
;
l_143:
;
; line 359:		   cyl=getcylfromcx(embr->partentries[k].beginseccyl);
;
	movzx	eax,bl
	shl	eax,04h
	movzx	eax,word [edi+eax+01c2h+00h]
	push	eax
	call	_getcylfromcx
	pop	ecx
	mov	esi,eax
;
; line 360:		   sec=getsecfromcx(embr->partentries[k].beginseccyl);
;
	movzx	eax,bl
	shl	eax,04h
	movzx	eax,word [edi+eax+01c2h+00h]
	push	eax
	call	_getsecfromcx
	pop	ecx
	mov	byte [ebp+0fffffffah],al
;
; line 362:		   diskoperation(drive+0x80,cyl,embr->partentries[k].beginhead,			 sec,1,&extmbrs[embrcount],2);
;
	push	byte 02h
	lea	eax,[_extmbrs]
	movzx	ecx,byte [ebp+0fffffff9h]
	imul	ecx,0202h
	add	eax,ecx
	push	eax
	push	byte 01h
	movzx	eax,byte [ebp+0fffffffah]
	push	eax
	movzx	eax,bl
	shl	eax,04h
	movzx	eax,byte [edi+eax+01c1h+00h]
	push	eax
	movzx	esi,si
	push	esi
	mov	al,byte [ebp+08h]
	add	al,080h
	movzx	eax,al
	push	eax
	call	_diskoperation
	add	esp,byte 01ch
;
; line 363:		   k=5;
;
	mov	bl,05h
;
; line 364:		   if(extmbrs[embrcount].signature==0xaa55)
;
	movzx	eax,byte [ebp+0fffffff9h]
	imul	eax,0202h
	movzx	eax,word [eax+0200h+_extmbrs+00h]
	cmp	eax,0aa55h
	jne	near	l_145
	mov	byte [ebp+0fffffff8h],00h
	jmp	l_149
l_147:
;
; line 368:		       if((c=extmbrs[embrcount].partentries[k1].systemcode)==0) break;
;
	movzx	eax,byte [ebp+0fffffff9h]
	imul	eax,0202h
	movzx	ecx,byte [ebp+0fffffff8h]
	shl	ecx,04h
	mov	al,byte [eax+ecx+01c4h+_extmbrs+00h+00h]
	mov	byte [ebp+0fffffffbh],al
	movzx	eax,al
	test	eax,eax
	je	near	l_150
l_151:
;
; line 369:		       if(c==5) k=k1;
;
	movzx	eax,byte [ebp+0fffffffbh]
	cmp	eax,byte 05h
	jne	short	l_153
	mov	bl,byte [ebp+0fffffff8h]
	jmp	l_154
l_153:
;
; line 374:			 filldevinfo(*devcount,2,c,0,drive,			     keepk+1,256*(embrcount+1)+k1+1,			     namehd,findfsname(c));
;
	movzx	eax,byte [ebp+0fffffffbh]
	push	eax
	call	_findfsname
	pop	ecx
	push	eax
	push	dword [ebp+0fffffffch]
	movzx	ax,byte [ebp+0fffffff9h]
	inc	ax
	movzx	eax,ax
	sal	eax,08h
	movzx	ecx,byte [ebp+0fffffff8h]
	add	eax,ecx
	inc	eax
	push	eax
	mov	al,byte [ebp+0fffffff7h]
	inc	al
	movzx	eax,al
	push	eax
	movzx	eax,byte [ebp+08h]
	push	eax
	push	byte 00h
	movzx	eax,byte [ebp+0fffffffbh]
	push	eax
	push	byte 02h
	mov	eax,dword [ebp+0ch]
	movzx	eax,byte [eax+00h]
	push	eax
	call	_filldevinfo
	add	esp,byte 024h
;
; line 375:			 (*devcount)++;
;
	mov	eax,dword [ebp+0ch]
	inc	byte [eax+00h]
;
; line 376:			}
;
l_154:
;
; line 377:		      }
;
;
; line 366:		     for(k1=0;k1<4;k1++)
;
l_148:
	inc	byte [ebp+0fffffff8h]
l_149:
	movzx	eax,byte [ebp+0fffffff8h]
	cmp	eax,byte 04h
	jb	near	l_147
l_150:
;
; line 378:		     if(k<4) embr=&extmbrs[embrcount++];
;
	movzx	ebx,bl
	cmp	ebx,byte 04h
	jnc	short	l_155
	mov	al,byte [ebp+0fffffff9h]
	inc	byte [ebp+0fffffff9h]
	movzx	eax,al
	imul	eax,0202h
	lea	edi,[_extmbrs]
	add	edi,eax
l_155:
;
; line 379:		    }
;
	jmp	l_146
l_145:
;
; line 380:		   else break;
;
	jmp	l_144
l_146:
;
; line 381:		  } while(k<4);
;
	movzx	ebx,bl
	cmp	ebx,byte 04h
	jb	near	l_143
l_144:
;
; line 382:	       k=keepk;
;
	mov	bl,byte [ebp+0fffffff7h]
;
; line 383:	      }
;
l_141:
;
; line 384:	    }
;
;
; line 345:	   for(k=0;k<4;k++)
;
l_136:
	inc	bl
l_137:
	movzx	ebx,bl
	cmp	ebx,byte 04h
	jb	near	l_135
l_138:
l_133:
;
; line 385:	  return 1;
;
	mov	al,01h
l_132:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp,ebp
	pop	ebp
	ret
;
; line 391:	 {
;
_searchdevices:
	push	ebp
	mov	ebp,esp
	sub	esp,byte 010h
	push	ebx
	push	esi
;
; line 393:	  byte devcount=0,h;
;
	mov	byte [ebp+0ffffffffh],00h
;
; line 394:	  const pchar namefd="%fd";
;
	lea	esi,[l_157]
;
; line 397:	  if(!getdiskdriveparms(0,&fddparms[0]))
;
	lea	eax,[_fddparms]
	push	eax
	push	byte 00h
	call	_getdiskdriveparms
	add	esp,byte 08h
	test	eax,eax
	jne	near	l_158
;
; line 400:	    filldevinfo(devcount,1,fddparms[0].drivetype,		0,0,0,0,namefd,"");
;
	lea	eax,[l_1]
	push	eax
	push	esi
	push	byte 00h
	push	byte 00h
	push	byte 00h
	push	byte 00h
	movsx	eax,word [06h+_fddparms]
	push	eax
	push	byte 01h
	movzx	eax,byte [ebp+0ffffffffh]
	push	eax
	call	_filldevinfo
	add	esp,byte 024h
;
; line 401:	    devcount++;
;
	inc	byte [ebp+0ffffffffh]
;
; line 402:	    if(fddparms[0].numdrives>1)
;
	movzx	eax,byte [04h+_fddparms]
	cmp	eax,byte 01h
	jbe	near	l_160
;
; line 403:	     if(!getdiskdriveparms(1,&fddparms[1]))
;
	lea	eax,[_fddparms]
	add	eax,byte 0ch
	push	eax
	push	byte 01h
	call	_getdiskdriveparms
	add	esp,byte 08h
	test	eax,eax
	jne	near	l_162
;
; line 406:		filldevinfo(devcount,1,fddparms[1].drivetype,		    0,1,0,0,namefd,"");
;
	lea	eax,[l_1]
	push	eax
	push	esi
	push	byte 00h
	push	byte 00h
	push	byte 01h
	push	byte 00h
	movsx	eax,word [012h+_fddparms]
	push	eax
	push	byte 01h
	movzx	eax,byte [ebp+0ffffffffh]
	push	eax
	call	_filldevinfo
	add	esp,byte 024h
;
; line 407:		devcount++;
;
	inc	byte [ebp+0ffffffffh]
;
; line 408:	       }
;
	jmp	l_163
l_162:
;
; line 409:	     else fddparms[1].drivetype=-1;
;
	mov	word [012h+_fddparms],0ffffffffh
l_163:
l_160:
;
; line 410:	   }
;
	jmp	l_159
l_158:
;
; line 411:	  else fddparms[0].numdrives=0;
;
	mov	byte [04h+_fddparms],00h
l_159:
;
; line 414:	  if(searchhdpartitions(0,&devcount))
;
	lea	eax,[ebp+0ffffffffh]
	push	eax
	push	byte 00h
	call	_searchhdpartitions
	add	esp,byte 08h
	test	al,al
	je	near	l_164
	mov	bl,01h
	jmp	l_168
l_166:
;
; line 417:	     if(!searchhdpartitions(h,&devcount))
;
	lea	eax,[ebp+0ffffffffh]
	push	eax
	movzx	ebx,bl
	push	ebx
	call	_searchhdpartitions
	add	esp,byte 08h
	test	al,al
	jne	short	l_170
;
; line 419:	       hddparms[h].drivetype=-1;
;
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 0ch
	mov	word [eax+06h+_hddparms+00h],0ffffffffh
;
; line 420:	       break;
;
	jmp	l_169
l_170:
;
; line 416:	    for(h=1;h<hddparms[0].numdrives;h++)
;
l_167:
	inc	bl
l_168:
	cmp	bl,byte [04h+_hddparms]
	jb	near	l_166
l_169:
;
; line 422:	   }
;
	jmp	l_165
l_164:
;
; line 423:	  else hddparms[0].numdrives=0;
;
	mov	byte [04h+_hddparms],00h
l_165:
;
; line 425:	  return devcount;
;
	movzx	ax,byte [ebp+0ffffffffh]
l_172:
	pop	esi
	pop	ebx
	mov	esp,ebp
	pop	ebp
	ret
;
; line 431:	 {
;
_loadfromdisk:
	push	ebp
	mov	ebp,esp
;
; line 438:	  loadbootsec(devnum,(char *)0x7c00);
;
	push	dword 07c00h
	movzx	eax,byte [ebp+08h]
	push	eax
	call	_loadbootsec
	add	esp,byte 08h
;
; line 439:	 }
;
	pop	ebp
	ret
;
; line 444:	 {
;
_loadfromrmvdisk:
	push	ebp
	mov	ebp,esp
	pop	ebp
	ret
;
; line 450:	 {
;
_loadfromtape:
	push	ebp
	mov	ebp,esp
	pop	ebp
	ret
;
; line 456:	 {
;
_loadfromport:
	push	ebp
	mov	ebp,esp
	pop	ebp
	ret
;
; line 462:	 {
;
_loadfromnet:
	push	ebp
	mov	ebp,esp
	pop	ebp
	ret
	times $$-$ & 3 nop
;
; line 467:	 {
;
_loadfromdevice:
	push	ebp
	mov	ebp,esp
	push	ebx
	movzx	ebx,byte [ebp+08h]
;
; line 468:	  switch(devinfo[devnum].devid)
;
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 033h
	movzx	eax,byte [eax+_devinfo+00h]
	cmp	eax,dword 07h
	jnc	near	l_173
	jmp	dword [eax*4+l_175]
l_175:
	dd	l_176
	dd	l_177
	dd	l_178
	dd	l_179
	dd	l_180
	dd	l_181
	dd	l_182
l_176:
;
; line 470:	    case 0:         break;
;
	jmp	l_174
l_177:
l_178:
;
; line 473:	    case 2:	   loadfromdisk(devnum);
;
	movzx	ebx,bl
	push	ebx
	call	_loadfromdisk
	pop	ecx
;
; line 475:	    break;case 3:	   loadfromrmvdisk(devnum);
;
	jmp	l_174
l_179:
	movzx	ebx,bl
	push	ebx
	call	_loadfromrmvdisk
	pop	ecx
;
; line 476:	    break;case 4:	   loadfromtape(devnum);
;
	jmp	l_174
l_180:
	movzx	ebx,bl
	push	ebx
	call	_loadfromtape
	pop	ecx
;
; line 477:	    break;case 5:	   loadfromport(devnum);
;
	jmp	l_174
l_181:
	movzx	ebx,bl
	push	ebx
	call	_loadfromport
	pop	ecx
;
; line 478:	    break;case 6:	   loadfromnet(devnum);
;
	jmp	l_174
l_182:
	movzx	ebx,bl
	push	ebx
	call	_loadfromnet
	pop	ecx
l_173:
l_174:
;
; line 480:	 }
;
	pop	ebx
	pop	ebp
	ret
;
; line 485:	 {
;
_loados_rfs:
	push	ebp
	mov	ebp,esp
	sub	esp,020ch
;
; line 486:	  char rfssig[]="rfs 01.00";
;
	mov	eax,dword [l_183]
	mov	dword [ebp+0fffffdf4h],eax
	mov	eax,dword [l_183+04h]
	mov	dword [ebp+0fffffdf4h+04h],eax
	mov	ax,word [l_183+04h+04h]
	mov	word [ebp+0fffffdf4h+04h+04h],ax
;
; line 489:	  if(!loadbootsec(devnum,bootsec)) return;
;
	lea	eax,[ebp+0fffffe00h]
	push	eax
	movzx	eax,byte [ebp+08h]
	push	eax
	call	_loadbootsec
	add	esp,byte 08h
l_184:
;
; line 490:	 }
;
l_186:
	mov	esp,ebp
	pop	ebp
	ret
;
; line 496:	 {
;
_loadstartupconfig:
	push	ebp
	mov	ebp,esp
	sub	esp,byte 08h
;
; line 500:	  if(devnum==255)
;
	movzx	eax,byte [ebp+08h]
	cmp	eax,0ffh
	jne	near	l_188
;
; line 502:	    wrstring("default startup configuration loaded. press any key...");
;
	lea	eax,[l_187]
	push	eax
	call	_wrstring
	pop	ecx
;
; line 503:	    waitkey();
;
	call	_waitkey
;
; line 504:	    wrchar('\r'); wrchara(' ',7,80);			
;
	push	byte 0dh
	call	_wrchar
	pop	ecx
	push	byte 050h
	push	byte 07h
	push	byte 020h
	call	_wrchara
	add	esp,byte 0ch
;
; line 505:	   }
;
l_188:
;
; line 508:	 }
;
	mov	esp,ebp
	pop	ebp
	ret
;
; line 511:	 {
;
_savestartupconfig:
	push	ebp
	mov	ebp,esp
	pop	ebp
	ret
;
; line 515:	 {
;
_editstartupconfig:
;
; line 516:	  wrchar(7);
;
	push	byte 07h
	call	_wrchar
	pop	ecx
;
; line 517:	 }
;
	ret
;
; line 523:	 {
;
_select:
	push	ebp
	mov	ebp,esp
	sub	esp,byte 020h
	push	ebx
	push	esi
	push	edi
;
; line 524:	  const pchar progver="       radiant system loader, version 1.0  (c) 1998 ret & com research";
;
	lea	eax,[l_190]
	mov	dword [ebp+0ffffffe0h],eax
;
; line 525:	  const pchar colnames[]={"device","type","subtype/parameters","protocol(s)"};
;
	push	esi
	push	edi
	lea	esi,[l_191]
	lea	edi,[ebp+0ffffffe4h]
	cld
	mov	ecx,04h
	rep	movsd
	pop	edi
	pop	esi
;
; line 526:	  const pchar sym=" Bò  I";
;
	lea	esi,[l_196]
;
; line 527:	  byte colwidth[4]={16,20,24,15};
;
	mov	eax,dword [l_197]
	mov	dword [ebp+0fffffff4h],eax
;
; line 528:	  byte i,j,k,sel=0,time=30;
;
	mov	byte [ebp+0fffffffch],00h
	mov	byte [ebp+0fffffffdh],01eh
;
; line 531:	  bool countdown=1;
;
	mov	byte [ebp+0ffffffffh],01h
;
; line 533:	  wrchar(' ');
;
	push	dword 0c9h
	call	_wrchar
	pop	ecx
;
; line 534:	  wrchara(sym[0],lightgray,78);
;
	push	byte 04eh
	push	byte 07h
	movsx	eax,byte [esi+00h]
	push	eax
	call	_wrchara
	add	esp,byte 0ch
;
; line 535:	  movecur(79,0);
;
	push	byte 00h
	push	byte 04fh
	call	_movecur
	add	esp,byte 08h
;
; line 536:	  wrchar('-'); wrchar(sym[4]);
;
	push	dword 0bbh
	call	_wrchar
	pop	ecx
	movsx	eax,byte [esi+04h]
	push	eax
	call	_wrchar
	pop	ecx
;
; line 537:	  wrstring(progver);
;
	push	dword [ebp+0ffffffe0h]
	call	_wrstring
	pop	ecx
;
; line 538:	  movecur(79,1);
;
	push	byte 01h
	push	byte 04fh
	call	_movecur
	add	esp,byte 08h
;
; line 539:	  wrchar(sym[4]); wrchar(sym[2]);
;
	movsx	eax,byte [esi+04h]
	push	eax
	call	_wrchar
	pop	ecx
	movsx	eax,byte [esi+02h]
	push	eax
	call	_wrchar
	pop	ecx
	mov	bl,00h
	jmp	l_202
l_200:
;
; line 542:	    wrchara(sym[1],lightgray,colwidth[i]);
;
	movzx	ebx,bl
	movzx	eax,byte [ebp+ebx+0fffffff4h]
	push	eax
	push	byte 07h
	movsx	eax,byte [esi+01h]
	push	eax
	call	_wrchara
	add	esp,byte 0ch
;
; line 543:	    movecur(wherex+colwidth[i],wherey);
;
	movzx	eax,byte [_wherey]
	push	eax
	movzx	ebx,bl
	mov	al,byte [_wherex]
	add	al,byte [ebp+ebx+0fffffff4h]
	movzx	eax,al
	push	eax
	call	_movecur
	add	esp,byte 08h
;
; line 544:	    if(i!=3) wrchar(' ');
;
	movzx	ebx,bl
	cmp	ebx,byte 03h
	je	short	l_204
	push	dword 0c2h
	call	_wrchar
	pop	ecx
l_204:
;
; line 545:	   }
;
;
; line 540:	  for(i=0;i<4;i++)
;
l_201:
	inc	bl
l_202:
	movzx	ebx,bl
	cmp	ebx,byte 04h
	jb	near	l_200
l_203:
;
; line 546:	  wrchar(sym[3]); wrchar(sym[4]);
;
	movsx	eax,byte [esi+03h]
	push	eax
	call	_wrchar
	pop	ecx
	movsx	eax,byte [esi+04h]
	push	eax
	call	_wrchar
	pop	ecx
	mov	bl,00h
	jmp	l_208
l_206:
;
; line 549:	    k=(colwidth[i]-strlen(colnames[i]))/2;
;
	movzx	ebx,bl
	mov	al,byte [ebp+ebx+0fffffff4h]
	push	eax
	movzx	ebx,bl
	push	dword [ebp+ebx*4+0ffffffe4h]
	call	_strlen
	pop	ecx
	mov	ecx,eax
	pop	eax
	movzx	eax,al
	sub	eax,ecx
	shr	eax,01h
	mov	byte [ebp+0fffffffbh],al
;
; line 550:	    movecur(wherex+k,3);
;
	push	byte 03h
	mov	al,byte [_wherex]
	add	al,byte [ebp+0fffffffbh]
	movzx	eax,al
	push	eax
	call	_movecur
	add	esp,byte 08h
;
; line 551:	    wrstring(colnames[i]);
;
	movzx	ebx,bl
	push	dword [ebp+ebx*4+0ffffffe4h]
	call	_wrstring
	pop	ecx
;
; line 552:	    movecur(wherex+k,3);
;
	push	byte 03h
	mov	al,byte [_wherex]
	add	al,byte [ebp+0fffffffbh]
	movzx	eax,al
	push	eax
	call	_movecur
	add	esp,byte 08h
;
; line 553:	    if(i!=3) wrchar(sym[5]);
;
	movzx	ebx,bl
	cmp	ebx,byte 03h
	je	short	l_210
	movsx	eax,byte [esi+05h]
	push	eax
	call	_wrchar
	pop	ecx
l_210:
;
; line 554:	   }
;
;
; line 547:	  for(i=0;i<4;i++)
;
l_207:
	inc	bl
l_208:
	movzx	ebx,bl
	cmp	ebx,byte 04h
	jb	near	l_206
l_209:
;
; line 555:	  wrchar(sym[4]); wrchar(sym[2]);
;
	movsx	eax,byte [esi+04h]
	push	eax
	call	_wrchar
	pop	ecx
	movsx	eax,byte [esi+02h]
	push	eax
	call	_wrchar
	pop	ecx
	mov	bl,00h
	jmp	l_214
l_212:
;
; line 558:	    wrchara('B',lightgray,colwidth[i]);
;
	movzx	ebx,bl
	movzx	eax,byte [ebp+ebx+0fffffff4h]
	push	eax
	push	byte 07h
	push	dword 0c4h
	call	_wrchara
	add	esp,byte 0ch
;
; line 559:	    movecur(wherex+colwidth[i],wherey);
;
	movzx	eax,byte [_wherey]
	push	eax
	movzx	ebx,bl
	mov	al,byte [_wherex]
	add	al,byte [ebp+ebx+0fffffff4h]
	movzx	eax,al
	push	eax
	call	_movecur
	add	esp,byte 08h
;
; line 560:	    if(i!=3) wrchar(' ');
;
	movzx	ebx,bl
	cmp	ebx,byte 03h
	je	short	l_216
	push	dword 0c5h
	call	_wrchar
	pop	ecx
l_216:
;
; line 561:	   }
;
;
; line 556:	  for(i=0;i<4;i++)
;
l_213:
	inc	bl
l_214:
	movzx	ebx,bl
	cmp	ebx,byte 04h
	jb	near	l_212
l_215:
;
; line 562:	  wrchar(sym[3]);
;
	movsx	eax,byte [esi+03h]
	push	eax
	call	_wrchar
	pop	ecx
	mov	bl,00h
	jmp	l_220
l_218:
;
; line 565:	    wrchar(sym[4]); wrchar(' '); wrstring(devinfo[i].name);
;
	movsx	eax,byte [esi+04h]
	push	eax
	call	_wrchar
	pop	ecx
	push	byte 020h
	call	_wrchar
	pop	ecx
	lea	eax,[_devinfo]
	movzx	ebx,bl
	mov	ecx,ebx
	imul	ecx,byte 033h
	add	eax,ecx
	add	eax,byte 08h
	push	eax
	call	_wrstring
	pop	ecx
;
; line 566:	    movecur(colwidth[0]+1,i+5);
;
	lea	eax,[ebx+05h]
	movzx	eax,al
	push	eax
	mov	al,byte [ebp+0fffffff4h]
	inc	al
	movzx	eax,al
	push	eax
	call	_movecur
	add	esp,byte 08h
;
; line 567:	    wrchar(sym[5]); wrchar(' '); wrstring(devtypeslist[devinfo[i].devid]);
;
	movsx	eax,byte [esi+05h]
	push	eax
	call	_wrchar
	pop	ecx
	push	byte 020h
	call	_wrchar
	pop	ecx
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 033h
	movzx	eax,byte [eax+_devinfo+00h]
	push	dword [eax*4+_devtypeslist+00h]
	call	_wrstring
	pop	ecx
;
; line 568:	    movecur(colwidth[0]+colwidth[1]+2,i+5);
;
	lea	eax,[ebx+05h]
	movzx	eax,al
	push	eax
	mov	al,byte [ebp+0fffffff4h]
	add	al,byte [ebp+0fffffff5h]
	add	al,byte 02h
	movzx	eax,al
	push	eax
	call	_movecur
	add	esp,byte 08h
;
; line 569:	    wrchar(sym[5]); wrchar(' '); wrstring(devinfo[i].parms);
;
	movsx	eax,byte [esi+05h]
	push	eax
	call	_wrchar
	pop	ecx
	push	byte 020h
	call	_wrchar
	pop	ecx
	lea	eax,[_devinfo]
	movzx	ebx,bl
	mov	ecx,ebx
	imul	ecx,byte 033h
	add	eax,ecx
	add	eax,byte 01ch
	push	eax
	call	_wrstring
	pop	ecx
;
; line 570:	    movecur(colwidth[0]+colwidth[1]+colwidth[2]+3,i+5);
;
	lea	eax,[ebx+05h]
	movzx	eax,al
	push	eax
	mov	al,byte [ebp+0fffffff4h]
	add	al,byte [ebp+0fffffff5h]
	add	al,byte [ebp+0fffffff6h]
	add	al,byte 03h
	movzx	eax,al
	push	eax
	call	_movecur
	add	esp,byte 08h
;
; line 571:	    wrchar(sym[5]); wrchar(' '); wrstring(prottypeslist[devinfo[i].protid]);
;
	movsx	eax,byte [esi+05h]
	push	eax
	call	_wrchar
	pop	ecx
	push	byte 020h
	call	_wrchar
	pop	ecx
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 033h
	movzx	eax,byte [eax+02h+_devinfo+00h]
	push	dword [eax*4+_prottypeslist+00h]
	call	_wrstring
	pop	ecx
;
; line 572:	    movecur(79,i+5); wrchar(sym[4]);
;
	lea	eax,[ebx+05h]
	movzx	eax,al
	push	eax
	push	byte 04fh
	call	_movecur
	add	esp,byte 08h
	movsx	eax,byte [esi+04h]
	push	eax
	call	_wrchar
	pop	ecx
;
; line 573:	   }
;
;
; line 563:	  for(i=0;i<numdevices;i++)
;
l_219:
	inc	bl
l_220:
	cmp	bl,byte [ebp+08h]
	jb	near	l_218
l_221:
;
; line 575:	  wrchar(sym[2]);
;
	movsx	eax,byte [esi+02h]
	push	eax
	call	_wrchar
	pop	ecx
	mov	byte [ebp+0fffffffbh],00h
	jmp	l_224
l_222:
;
; line 578:	    wrchara(sym[1],lightgray,colwidth[k]);
;
	movzx	eax,byte [ebp+0fffffffbh]
	movzx	eax,byte [ebp+eax+0fffffff4h]
	push	eax
	push	byte 07h
	movsx	eax,byte [esi+01h]
	push	eax
	call	_wrchara
	add	esp,byte 0ch
;
; line 579:	    movecur(wherex+colwidth[k],wherey);
;
	movzx	eax,byte [_wherey]
	push	eax
	movzx	eax,byte [ebp+0fffffffbh]
	mov	cl,byte [_wherex]
	add	cl,byte [ebp+eax+0fffffff4h]
	movzx	ecx,cl
	push	ecx
	call	_movecur
	add	esp,byte 08h
;
; line 580:	    if(k!=3) wrchar(' ');
;
	movzx	eax,byte [ebp+0fffffffbh]
	cmp	eax,byte 03h
	je	short	l_226
	push	dword 0c1h
	call	_wrchar
	pop	ecx
l_226:
;
; line 581:	   }
;
;
; line 576:	  for(k=0;k<4;k++)
;
l_223:
	inc	byte [ebp+0fffffffbh]
l_224:
	movzx	eax,byte [ebp+0fffffffbh]
	cmp	eax,byte 04h
	jb	near	l_222
l_225:
;
; line 582:	  wrchar(sym[3]);
;
	movsx	eax,byte [esi+03h]
	push	eax
	call	_wrchar
	pop	ecx
;
; line 584:	  wrchar(sym[4]);
;
	movsx	eax,byte [esi+04h]
	push	eax
	call	_wrchar
	pop	ecx
;
; line 585:	  movecur(79,i+6); wrchar(sym[4]);
;
	lea	eax,[ebx+06h]
	movzx	eax,al
	push	eax
	push	byte 04fh
	call	_movecur
	add	esp,byte 08h
	movsx	eax,byte [esi+04h]
	push	eax
	call	_wrchar
	pop	ecx
;
; line 586:	  wrchar('A'); wrchara(sym[0],lightgray,78);
;
	push	dword 0c8h
	call	_wrchar
	pop	ecx
	push	byte 04eh
	push	byte 07h
	movsx	eax,byte [esi+00h]
	push	eax
	call	_wrchara
	add	esp,byte 0ch
;
; line 587:	  movecur(79,i+7); wrchar('B');
;
	lea	eax,[ebx+07h]
	movzx	eax,al
	push	eax
	push	byte 04fh
	call	_movecur
	add	esp,byte 08h
	push	dword 0bch
	call	_wrchar
	pop	ecx
	mov	bl,00h
	jmp	l_230
l_228:
;
; line 590:	   if(devinfo[i].devid==2)
;
	movzx	ebx,bl
	mov	eax,ebx
	imul	eax,byte 033h
	movzx	eax,byte [eax+_devinfo+00h]
	cmp	eax,byte 02h
	jne	short	l_232
;
; line 592:	     sel=i;
;
	mov	byte [ebp+0fffffffch],bl
;
; line 593:	     break;
;
	jmp	l_231
l_232:
;
; line 589:	  for(i=0;i<numdevices;i++)
;
l_229:
	inc	bl
l_230:
	cmp	bl,byte [ebp+08h]
	jb	near	l_228
l_231:
;
; line 596:	  movecur(9,numdevices+6);
;
	mov	al,byte [ebp+08h]
	add	al,byte 06h
	movzx	eax,al
	push	eax
	push	byte 09h
	call	_movecur
	add	esp,byte 08h
;
; line 597:	  wrstring("selected: ");
;
	lea	eax,[l_198]
	push	eax
	call	_wrstring
	pop	ecx
;
; line 598:	  wrstring(devinfo[i].name);
;
	lea	eax,[_devinfo]
	movzx	ebx,bl
	mov	ecx,ebx
	imul	ecx,byte 033h
	add	eax,ecx
	add	eax,byte 08h
	push	eax
	call	_wrstring
	pop	ecx
;
; line 599:	  wrstringxy(49,numdevices+6,"time remaining: ");
;
	lea	eax,[l_199]
	push	eax
	mov	al,byte [ebp+08h]
	add	al,byte 06h
	movzx	eax,al
	push	eax
	push	byte 031h
	call	_wrstringxy
	add	esp,byte 0ch
;
; line 600:	  movecur(0,numdevices+8);
;
	mov	al,byte [ebp+08h]
	add	al,byte 08h
	movzx	eax,al
	push	eax
	push	byte 00h
	call	_movecur
	add	esp,byte 08h
;
; line 601:	  lightline(sel);
;
	movzx	eax,byte [ebp+0fffffffch]
	push	eax
	call	_lightline
	pop	ecx
	jmp	l_236
l_234:
;
; line 604:	    if(keypressed())
;
	call	_keypressed
	test	al,al
	je	near	l_238
;
; line 606:	      if(countdown)
;
	cmp	byte [ebp+0ffffffffh],byte 00h
	je	near	l_240
;
; line 608:		countdown=0;
;
	mov	byte [ebp+0ffffffffh],00h
;
; line 609:		movecur(49,numdevices+6);
;
	mov	al,byte [ebp+08h]
	add	al,byte 06h
	movzx	eax,al
	push	eax
	push	byte 031h
	call	_movecur
	add	esp,byte 08h
;
; line 610:		wrchara(' ',lightgray,24);
;
	push	byte 018h
	push	byte 07h
	push	byte 020h
	call	_wrchara
	add	esp,byte 0ch
;
; line 611:		movecur(0,numdevices+8);
;
	mov	al,byte [ebp+08h]
	add	al,byte 08h
	movzx	eax,al
	push	eax
	push	byte 00h
	call	_movecur
	add	esp,byte 08h
;
; line 612:	       }
;
l_240:
;
; line 613:	      switch(ch=bkey=waitkey())
;
	call	_waitkey
	mov	edi,eax
	mov	byte [ebp+0fffffffeh],al
	cmp	al,byte 00h
	je	short	l_244
	cmp	al,byte 0dh
	je	near	l_245
	jmp	l_242
l_244:
;
; line 615:		case '\0': switch(bkey >> 8)
;
	movzx	eax,di
	sar	eax,08h
	cmp	eax,dword 048h
	je	near	l_249
	ja	short	l_253
	cmp	eax,dword 041h
	je	near	l_251
	ja	near	l_246
	cmp	eax,dword 03bh
	je	short	l_248
	jmp	l_246
l_253:
	cmp	eax,dword 05ah
	je	near	l_252
	ja	near	l_246
	cmp	eax,dword 050h
	je	near	l_250
	jmp	l_246
l_248:
;
; line 617:			     case 59: help();
;
	call	_help
;
; line 618:			     break;case 72: if(sel>0)
;
	jmp	l_247
l_249:
	movzx	eax,byte [ebp+0fffffffch]
	test	eax,eax
	jbe	near	l_254
;
; line 620:					    blankline(sel);
;
	movzx	eax,byte [ebp+0fffffffch]
	push	eax
	call	_blankline
	pop	ecx
;
; line 621:					    lightline(--sel);
;
	dec	byte [ebp+0fffffffch]
	movzx	eax,byte [ebp+0fffffffch]
	push	eax
	call	_lightline
	pop	ecx
;
; line 622:					   }
;
l_254:
;
; line 623:			     break;case 80: if(sel<numdevices-1)
;
	jmp	l_247
l_250:
	movzx	eax,byte [ebp+08h]
	dec	eax
	movzx	ecx,byte [ebp+0fffffffch]
	cmp	ecx,eax
	jnc	near	l_256
;
; line 625:					      blankline(sel);
;
	movzx	eax,byte [ebp+0fffffffch]
	push	eax
	call	_blankline
	pop	ecx
;
; line 626:					      lightline(++sel);
;
	inc	byte [ebp+0fffffffch]
	movzx	eax,byte [ebp+0fffffffch]
	push	eax
	call	_lightline
	pop	ecx
;
; line 627:					     }
;
l_256:
;
; line 628:			     break;case 65: loadstartupconfig(sel);
;
	jmp	l_247
l_251:
	movzx	eax,byte [ebp+0fffffffch]
	push	eax
	call	_loadstartupconfig
	pop	ecx
;
; line 629:					  if(!errorcode) editstartupconfig();
;
	cmp	dword [_errorcode],byte 00h
	jne	short	l_258
	call	_editstartupconfig
	jmp	l_259
l_258:
;
; line 630:					  else errorcode=0;
;
	mov	dword [_errorcode],00h
l_259:
;
; line 631:			     break;case 90: loadstartupconfig(255); 
;
	jmp	l_247
l_252:
	push	dword 0ffh
	call	_loadstartupconfig
	pop	ecx
l_246:
l_247:
;
; line 634:			   movecur(19,numdevices+6);
;
	mov	al,byte [ebp+08h]
	add	al,byte 06h
	movzx	eax,al
	push	eax
	push	byte 013h
	call	_movecur
	add	esp,byte 08h
;
; line 635:			   wrstring(devinfo[sel].name); wrchara(' ',lightgray,5);
;
	lea	eax,[_devinfo]
	movzx	ecx,byte [ebp+0fffffffch]
	imul	ecx,byte 033h
	add	eax,ecx
	add	eax,byte 08h
	push	eax
	call	_wrstring
	pop	ecx
	push	byte 05h
	push	byte 07h
	push	byte 020h
	call	_wrchara
	add	esp,byte 0ch
;
; line 636:			   movecur(0,numdevices+8);
;
	mov	al,byte [ebp+08h]
	add	al,byte 08h
	movzx	eax,al
	push	eax
	push	byte 00h
	call	_movecur
	add	esp,byte 08h
;
; line 637:			   continue;
;
	jmp	l_235
l_245:
;
; line 639:		case '\r': return sel;
;
	mov	al,byte [ebp+0fffffffch]
	jmp	l_260
l_242:
l_243:
;
; line 641:	     }
;
	jmp	l_239
l_238:
;
; line 642:	    else if(countdown)
;
	cmp	byte [ebp+0ffffffffh],byte 00h
	je	near	l_261
;
; line 644:		   movecur(65,numdevices+6);
;
	mov	al,byte [ebp+08h]
	add	al,byte 06h
	movzx	eax,al
	push	eax
	push	byte 041h
	call	_movecur
	add	esp,byte 08h
;
; line 645:		   wdecout(--time); wrchar(' ');
;
	dec	byte [ebp+0fffffffdh]
	movzx	eax,byte [ebp+0fffffffdh]
	push	eax
	call	_wdecout
	pop	ecx
	push	byte 020h
	call	_wrchar
	pop	ecx
;
; line 646:		   movecur(0,numdevices+8);
;
	mov	al,byte [ebp+08h]
	add	al,byte 08h
	movzx	eax,al
	push	eax
	push	byte 00h
	call	_movecur
	add	esp,byte 08h
;
; line 647:		   delay1withkb();
;
	call	_delay1withkb
;
; line 648:		   if(!time) return sel;
;
	cmp	byte [ebp+0fffffffdh],byte 00h
	jne	short	l_263
	mov	al,byte [ebp+0fffffffch]
	jmp	l_260
l_263:
;
; line 649:		  }
;
l_261:
l_239:
;
; line 650:	   }
;
;
; line 602:	  for(;;)
;
l_235:
l_236:
	jmp	l_234
l_237:
;
; line 651:	 }
;
l_260:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp,ebp
	pop	ebp
	ret
[global	_main]
;
; line 656:	 {
;
_main:
	push	ebp
	mov	ebp,esp
	sub	esp,byte 018h
	push	ebx
;
; line 657:	  char k,*name,buf[16					+1]="%fd1";
;
	push	esi
	push	edi
	lea	esi,[l_265]
	lea	edi,[ebp+0ffffffech]
	cld
	mov	ecx,04h
	rep	movsd
	movsb
	pop	edi
	pop	esi
;
; line 661:	  setvidpg(7);
;
	push	byte 07h
	call	_setvidpg
	pop	ecx
;
; line 662:	  clrscr();
;
	call	_clrscr
;
; line 663:	  window(0,0,79,24);
;
	push	byte 018h
	push	byte 04fh
	push	byte 00h
	push	byte 00h
	call	_window
	add	esp,byte 010h
;
; line 666:	  if((numdevs=searchdevices())==0) error(8);
;
	call	_searchdevices
	mov	word [ebp+0fffffffeh],ax
	movzx	eax,ax
	test	eax,eax
	jne	short	l_266
	push	byte 08h
	call	_error
	pop	ecx
l_266:
;
; line 669:	  k=select(numdevs);
;
	movzx	eax,word [ebp+0fffffffeh]
	push	eax
	call	_select
	pop	ecx
	mov	bl,al
;
; line 670:	  loados_rfs(k);
;
	movsx	ebx,bl
	push	ebx
	call	_loados_rfs
	pop	ecx
;
; line 671:	  loadfromdevice(k);
;
	movsx	ebx,bl
	push	ebx
	call	_loadfromdevice
	pop	ecx
;
; line 673:	  return errorcode;
;
	mov	eax,dword [_errorcode]
l_268:
	pop	ebx
	mov	esp,ebp
	pop	ebp
	ret

l_199:
	db	054h,069h,06dh,065h,020h,072h,065h,06dh,061h,069h,06eh,069h
	db	06eh,067h,03ah,020h,00h
l_198:
	db	053h,065h,06ch,065h,063h,074h,065h,064h,03ah,020h,00h
l_196:
	db	0cdh,0c4h,0c7h,0b6h,0bah,0b3h,00h
l_195:
	db	050h,072h,06fh,074h,06fh,063h,06fh,06ch,028h,073h,029h,00h
l_194:
	db	053h,075h,062h,074h,079h,070h,065h,02fh,070h,061h,072h,061h
	db	06dh,065h,074h,065h,072h,073h,00h
l_193:
	db	054h,079h,070h,065h,00h
l_192:
	db	044h,065h,076h,069h,063h,065h,00h
l_190:
	db	020h,020h,020h,020h,020h,020h,020h,052h,061h,064h,069h,061h
	db	06eh,074h,020h,053h,079h,073h,074h,065h,06dh,020h,04ch,06fh
	db	061h,064h,065h,072h,02ch,020h,076h,065h,072h,073h,069h,06fh
	db	06eh,020h,031h,02eh,030h,020h,020h,028h,063h,029h,020h,031h
	db	039h,039h,038h,020h,052h,045h,054h,020h,026h,020h,043h,04fh
	db	04dh,020h,052h,065h,073h,065h,061h,072h,063h,068h,00h
l_187:
	db	044h,065h,066h,061h,075h,06ch,074h,020h,073h,074h,061h,072h
	db	074h,075h,070h,020h,063h,06fh,06eh,066h,069h,067h,075h,072h
	db	061h,074h,069h,06fh,06eh,020h,06ch,06fh,061h,064h,065h,064h
	db	02eh,020h,050h,072h,065h,073h,073h,020h,061h,06eh,079h,020h
	db	06bh,065h,079h,02eh,02eh,02eh,00h
l_157:
	db	025h,066h,064h,00h
l_129:
	db	025h,068h,064h,00h
l_72:
	db	08h,020h,08h,00h
l_51:
	db	02eh,020h,050h,072h,065h,073h,073h,020h,061h,06eh,079h,020h
	db	06bh,065h,079h,02eh,02eh,02eh,0ah,00h
l_50:
	db	050h,072h,06fh,067h,072h,061h,06dh,020h,074h,065h,072h,06dh
	db	069h,06eh,061h,074h,065h,064h,020h,06eh,06fh,072h,06dh,061h
	db	06ch,06ch,079h,00h
l_49:
	db	06eh,06fh,020h,06ch,06fh,061h,064h,061h,062h,06ch,065h,020h
	db	064h,065h,076h,069h,063h,065h,073h,00h
l_48:
	db	062h,06fh,06fh,074h,020h,073h,065h,063h,074h,06fh,072h,020h
	db	073h,069h,067h,06eh,061h,074h,075h,072h,065h,020h,06eh,06fh
	db	074h,020h,066h,06fh,075h,06eh,064h,00h
l_47:
	db	073h,074h,061h,072h,074h,075h,070h,020h,063h,06fh,06eh,066h
	db	069h,067h,075h,072h,061h,074h,069h,06fh,06eh,020h,064h,061h
	db	074h,061h,020h,06eh,06fh,074h,020h,066h,06fh,075h,06eh,064h
	db	00h
l_46:
	db	064h,069h,073h,06bh,020h,06fh,070h,065h,072h,061h,074h,069h
	db	06fh,06eh,020h,066h,061h,069h,06ch,075h,072h,065h,00h
l_45:
	db	045h,052h,052h,04fh,052h,03ah,020h,00h
l_44:
	db	046h,041h,054h,041h,04ch,020h,00h
l_43:
	db	052h,06fh,06fh,074h,020h,06ch,069h,06eh,06bh,069h,06eh,067h
	db	020h,070h,06fh,069h,06eh,074h,03dh,041h,03ah,00h
l_42:
	db	052h,06fh,06fh,074h,020h,064h,065h,076h,069h,063h,065h,03dh
	db	025h,066h,064h,031h,00h
l_41:
	db	041h,058h,02eh,032h,035h,00h
l_40:
	db	04eh,045h,054h,042h,045h,055h,049h,00h
l_39:
	db	049h,050h,058h,00h
l_38:
	db	054h,043h,050h,02fh,049h,050h,00h
l_37:
	db	02dh,00h
l_36:
	db	04eh,065h,074h,077h,06fh,072h,06bh,020h,063h,06fh,06eh,074h
	db	072h,06fh,06ch,06ch,065h,072h,00h
l_35:
	db	050h,06fh,072h,074h,00h
l_34:
	db	054h,061h,070h,065h,00h
l_33:
	db	052h,065h,06dh,06fh,076h,061h,062h,06ch,065h,020h,064h,069h
	db	073h,06bh,00h
l_32:
	db	048h,061h,072h,064h,020h,064h,069h,073h,06bh,00h
l_31:
	db	046h,06ch,06fh,070h,070h,079h,020h,064h,069h,073h,06bh,00h
l_30:
	db	045h,06dh,070h,074h,079h,00h
l_29:
	db	052h,046h,053h,020h,073h,077h,061h,070h,00h
l_28:
	db	052h,046h,053h,020h,06eh,061h,074h,069h,076h,065h,00h
l_27:
	db	042h,042h,054h,00h
l_26:
	db	044h,04fh,053h,020h,073h,065h,063h,06fh,06eh,064h,061h,072h
	db	079h,00h
l_25:
	db	044h,04fh,053h,020h,052h,02fh,04fh,00h
l_24:
	db	044h,04fh,053h,020h,061h,063h,063h,065h,073h,073h,00h
l_23:
	db	043h,050h,02fh,04dh,00h
l_22:
	db	042h,053h,044h,049h,020h,073h,077h,061h,070h,00h
l_21:
	db	042h,053h,044h,049h,020h,046h,053h,00h
l_20:
	db	042h,053h,044h,020h,033h,038h,036h,00h
l_19:
	db	04ch,069h,06eh,075h,078h,020h,06eh,061h,074h,069h,076h,065h
	db	00h
l_18:
	db	04ch,069h,06eh,075h,078h,020h,073h,077h,061h,070h,00h
l_17:
	db	04dh,069h,06eh,069h,078h,00h
l_16:
	db	04fh,06ch,064h,020h,04dh,069h,06eh,069h,078h,00h
l_15:
	db	050h,043h,02fh,049h,058h,00h
l_14:
	db	04eh,06fh,076h,065h,06ch,06ch,00h
l_13:
	db	04dh,069h,063h,072h,06fh,070h,06fh,072h,074h,00h
l_12:
	db	056h,065h,06eh,069h,078h,020h,032h,038h,036h,00h
l_11:
	db	04fh,053h,02fh,032h,020h,062h,06fh,06fh,074h,020h,06dh,061h
	db	06eh,061h,067h,065h,072h,00h
l_10:
	db	041h,049h,058h,020h,062h,06fh,06fh,074h,061h,062h,06ch,065h
	db	00h
l_9:
	db	041h,049h,058h,00h
l_8:
	db	04fh,053h,02fh,032h,020h,048h,050h,046h,053h,00h
l_7:
	db	044h,04fh,053h,020h,046h,041h,054h,031h,036h,020h,03eh,03dh
	db	033h,032h,04dh,00h
l_6:
	db	044h,04fh,053h,020h,065h,078h,074h,065h,06eh,064h,065h,064h
	db	00h
l_5:
	db	044h,04fh,053h,020h,046h,041h,054h,031h,036h,020h,03ch,033h
	db	032h,04dh,00h
l_4:
	db	058h,045h,04eh,049h,058h,020h,075h,073h,072h,00h
l_3:
	db	058h,045h,04eh,049h,058h,020h,072h,06fh,06fh,074h,00h
l_2:
	db	044h,04fh,053h,020h,046h,041h,054h,031h,032h,00h
l_1:
	db	00h
section .data
[global	_errorcode]

_errorcode	dd	00h
[global	_fstypeslist]

_fstypeslist	db	00h
	resb	03h
	dd	l_1
	db	01h
	resb	03h
	dd	l_2
	db	02h
	resb	03h
	dd	l_3
	db	03h
	resb	03h
	dd	l_4
	db	04h
	resb	03h
	dd	l_5
	db	05h
	resb	03h
	dd	l_6
	db	06h
	resb	03h
	dd	l_7
	db	07h
	resb	03h
	dd	l_8
	db	08h
	resb	03h
	dd	l_9
	db	09h
	resb	03h
	dd	l_10
	db	0ah
	resb	03h
	dd	l_11
	db	040h
	resb	03h
	dd	l_12
	db	052h
	resb	03h
	dd	l_13
	db	064h
	resb	03h
	dd	l_14
	db	075h
	resb	03h
	dd	l_15
	db	080h
	resb	03h
	dd	l_16
	db	081h
	resb	03h
	dd	l_17
	db	082h
	resb	03h
	dd	l_18
	db	083h
	resb	03h
	dd	l_19
	db	0a5h
	resb	03h
	dd	l_20
	db	0b7h
	resb	03h
	dd	l_21
	db	0b8h
	resb	03h
	dd	l_22
	db	0dbh
	resb	03h
	dd	l_23
	db	0e1h
	resb	03h
	dd	l_24
	db	0e3h
	resb	03h
	dd	l_25
	db	0f2h
	resb	03h
	dd	l_26
	db	0ffh
	resb	03h
	dd	l_27
	db	032h
	resb	03h
	dd	l_28
	db	033h
	resb	03h
	dd	l_29
	resb	010h
[global	_devtypeslist]

_devtypeslist	dd	l_30,l_31,l_32,l_33,l_34,l_35,l_36
[global	_prottypeslist]

_prottypeslist	dd	l_37,l_38,l_39,l_40,l_41
[global	_defaultconfig]

_defaultconfig	dd	l_42,l_43

l_121	db	055h,06eh,06bh,06eh,06fh,077h,06eh,00h

l_183	db	052h,046h,053h,020h,030h,031h,02eh,030h,030h,00h
	resb	02h

l_191	dd	l_192,l_193,l_194,l_195

l_197	db	010h,014h,018h,0fh

l_265	db	025h,066h,064h,031h,00h
	resb	0ch
section .bss
[global	_fddparms]

_fddparms	resb	018h
[global	_hddparms]

_hddparms	resb	018h
[global	_mainmbrs]

_mainmbrs	resb	0404h
[global	_extmbrs]

_extmbrs	resb	01010h
[global	_devinfo]

_devinfo	resb	0cc0h

section .text
extern	_clrscr
extern	_strend
extern	_window
extern	_diskoperation
extern	_delay1withkb
extern	_waitkey
extern	_wdecout
extern	_strcopy
extern	_getdiskdriveparms
extern	_wrchara
extern	_movecur
extern	_keypressed
extern	_wrvidmem
extern	_strlen
extern	_wrchar
extern	_wrstring
extern	_wrstringxy
extern	_setvidpg

section .data
extern	_wherey
extern	_wherex
extern	_currvidmode
