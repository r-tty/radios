;-------------------------------------------------------------------------------
; sys.ah - various system-wide definitions.
;-------------------------------------------------------------------------------

%ifndef _sys_ah
%define _sys_ah

%include "cpu/cpu.ah"
%include "cpu/descript.ah"
%include "macros/inlines.ah"
%include "siginfo.ah"

; Global descriptors
%define	KERNELCODE	8
%define	KERNELDATA	10h
%define	USERCODE	18h
%define	USERDATA	20h
%define	KTSS		28h
%define	KLDT		30h
%define	ULDT		38h

; Selectors
%define	DRV_CSEG	(DRVCODE | SELECTOR_RPL1)
%define	DRV_DSEG	(DRVDATA | SELECTOR_RPL1)
%define	USER_CSEG	(USERCODE | SELECTOR_RPL3)
%define	USER_DSEG	(USERDATA | SELECTOR_RPL3)

; Size of GDT and IDT (in bytes)
%define GDT_size	40h
%define	IDT_size	800h

; Components of the address
%define	ADDR_PDEMASK	0FFC00000h
%define	ADDR_PTEMASK	3FF000h
%define	ADDR_OFSMASK	0FFFh

; Upper memory and HMA starts here
%define UPPERMEMSTART	100000h
%define HMASTART	UPPERMEMSTART
; HMA is a working area of BTL
%define HMASIZE		10000h

; From the kernel's linear perspective, the user resides in quandrants 2 and 3
%define USERAREASTART	80000000h

; Shared libraries are mapped beginning from here (again, as kernel sees it)
%define SHLIBAREASTART	0D0000000h

; For user, address space is 2G, and his stack resides on the top of it
%define USTACKTOP	80000000h

; Base address at which stack starts. ESP will start at the top of this,
; and grow downwards.
%define USTACKADDR	(USTACKTOP-UMAXSTACK)

; To get an interrupt number by IRQ
%define IRQVECTOR(x)	20h + x			; IRQ0 -> INT 20h

; Task manager parameters, like PID, CHID, COID
SYSMGR_PID		EQU	1
SYSMGR_CHID		EQU	1
SYSMGR_COID		EQU	40000000h
SYSMGR_HANDLE		EQU	0

; Scheduler information - used by SchedInfo()
struc tSchedInfo
.PrioMin	RESD	1
.PrioMax	RESD	1
.Interval	RESQ	1
.PrioPriv	RESD	1
.Reserved	RESD	1
endstruc

; Definitions for type and subtype of any pulse.
PULSE_TYPE		EQU	0
PULSE_SUBTYPE		EQU	0
PULSE_CODE_UNBLOCK	EQU	-32	; value - rcvid
PULSE_CODE_DISCONNECT	EQU	-33	; value - server connection
PULSE_CODE_THREADDEATH	EQU	-34	; value - thread id
PULSE_CODE_COIDDEATH	EQU	-35	; value - thread id
PULSE_CODE_NET_ACK	EQU	-36	; value - vtid
PULSE_CODE_NET_UNBLOCK	EQU	-37	; value - vtid

PULSE_CODE_MINAVAIL	EQU	0
PULSE_CODE_MAXAVAIL	EQU	127

PULSE_PRIO_HEAD		EQU	4000h
PULSE_PRIO_VTID		EQU	40000000h

; Pulse structure
struc tPulse
.Type		RESW	1
.Subtype	RESW	1
.Code		RESB	1
.Zero		RESB	3
.SigValue	RESD	1
.SCoID		RESD	1
endstruc

; Interrupt flags
HARD_FLAGS_END	EQU	1

; Flags which can be applied to a pulse type
PULSE_IF_UNIQUE	EQU	1000h
PULSE_REPLACE	EQU	2000h

; Flag bits for InterruptAttach[Event]
INTR_FLAGS_END		EQU	1
INTR_FLAGS_SMPRDY	EQU	2
INTR_FLAGS_PROCESS	EQU	4
INTR_FLAGS_TRK_MSK	EQU	8

; System independent interrupt classes for InterruptAttach[Event]
INTR_CLASS_EXTERNAL	EQU	0
INTR_CLASS_SYNTHETIC	EQU	7FFFh << 16

INTR_SPARE	EQU	INTR_CLASS_SYNTHETIC | 0FFFFh

HOOK_TRACE	EQU	INTR_CLASS_SYNTHETIC | 0
HOOK_IDLE	EQU	INTR_CLASS_SYNTHETIC | 1
HOOK_LAST	EQU	INTR_CLASS_SYNTHETIC | 1

; Flags for MsgReadiov
READIOV_SEND	EQU	0
READIOV_REPLY	EQU	1

; Clock period structure
struc tClockPeriod
.nsec		RESD	1
.fract		RESD	1
endstruc

; Limits
LIMITS_PROCESS		EQU	0
LIMITS_THREAD		EQU	1
LIMITS_TIMER		EQU	2
LIMITS_PULSE		EQU	3
LIMITS_SYNC		EQU	4
LIMITS_CONNECT		EQU	5
LIMITS_CHANNEL		EQU	6
LIMITS_INTERRUPT	EQU	7
LIMITS_SYNCEVENT	EQU	8
LIMITS_NUM		EQU	9

; Operation to tell MsgKeyData to verify instead of calculate
KEYDATA_VERIFY		EQU	0
KEYDATA_CALCULATE	EQU	1

%endif
