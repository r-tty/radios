;-------------------------------------------------------------------------------
;  process.ah - process definitions.
;-------------------------------------------------------------------------------

; Process descriptor structure
struc tProcDesc
.PID		RESD	1			; PID
.Parent		RESD	1			; Parent PCB
.FHandlesAddr	RESD	1			; Address of file handles table
.NumFHandles	RESB	1			; Max. number of file handles
.Flags		RESB	1			; Flags
.EnvSize	RESW	1			; Address and size of
.EnvAddr	RESD	1			; environment
.PageDir	RESD	1			; Page directory address
.FirstMCB	RESD	1			; First MCB address
.LastMCB	RESD	1			; Last MCB address
.EventHandler	RESD	1			; Event handler address
.Module		RESW	1			; Module number
.FSLP		RESB	1			; Current FSLP
.Reserved	RESB	1
.CurrDirIndex	RESD	1			; Current directory index
.ThreadList	RESD	1			; Thread list head
.Next		RESD	1			; Next PCB in list
.Prev		RESD	1			; Previous PCB in list

.Reserved2	RESD	12			; Complement to 128 bytes
endstruc

%define	PROCDESCSHIFT	7			; log2(tProcDesc_size)

; Process descriptor flags
%define	PDFL_USER	1			; Set = user process


; Process initialization structure
struc tProcInit
.EnvSize	RESW	1			; Environment size
.MaxFHandles	RESB	1			; Maximum file handles
.Reserved	RESB	1
.EventHandler	RESD	1			; Event handler address
endstruc

; Zero address of process descriptor is valid - it means kernel process
; (with PID=0). This macro checks whether its argument (register) is 0
; and if so - loads there address of kernel PCB
%macro mIsKernProc 1
%if %0==1
	or	%1,%1
	jnz	short %%Done
	mov	%1,[?ProcListPtr]
%%Done:
%else
%error mIsKernProc: invalid number of args
%endif
%endmacro

; Macro that converts PID to process descriptor address (PDA)
%macro mPID2PDA 0-1
%if %0>0
	mov	eax,%1
%endif
	mov	ebx,eax
	shl	ebx,PROCDESCSHIFT
	add	ebx,[?ProcListPtr]
%endmacro

